# ReGSM-Design

## 前言

要实现这种东西肯定不是什么容易的事情。。。尤其像是比如说tmux在linux下限定而windows用不了一样
> 不要说什么cygwin msys 我们只讨论原装

所幸，我们可以通过重定向stdio的方式来"Detour", aka, 不通过在服务器内部做对应的扩展（比如说V社的SM/MM/AMX，MC的BitBukket啥的），
转而通过重定向控制台应用的输入输出流，并通过其他的方法实现"后台运行"。
> 毕竟Non-GUI可不提供像是alt+tab这种功能，别做梦了。

但这样的话其实也不是什么很容易的事情，容我细细道来：
1. 需要自己造轮子：
   1. 避免平台依赖：LinuxGSM完完全全依赖tmux，WindowsGSM完完全全依赖Windows GUI。
      > WindowsGSM如果挂了下面的服务器实际上也是要跟着挂的
   2. 避免引入非必要依赖：如果想让windows支持tmux之类的软件需要安装msys或cygwin，但那样等同于没装，而且实际上也没办法做到和cmd/powershell互通，得不偿失。
   3. 跨平台兼容：参考 1.1)，不再说明。
2. 复杂度
   1. 拆分：我们提到没办法用tmux，所以你需要自己实现tmux的核心思想。这时候相当于说你需要看情况拆分一些内容，以期实现平台无关。
      > 有些Lin有的Win没有，反过来也一样，所以就得绕一大圈，确保跨平台兼容。
   2. 完全基于网络：因为需要拆分，所以在端对端的交互上是无可避免的要使用诸如HTTP, Socket, WebSocket等技术，这对于复杂度来说实际上是指数型上升的。
      > 虽然说有些号称"大道至简"的语言信誓旦旦的说复杂度会非常低，但是吧，我很怀疑：一个项目复杂度只要上升到足够高，任何所谓的简单其实都只是噱头。
   3. 技术储备：你需要手动实现如daemon, HTTP/Websocket等传递信息到stdin，输出stdout到其他终端/前端，前后端交互，节点等。这些内容哪个都不是什么小问题。

值得吗？当然是值得的：可以统一Windows和Linux，何乐而不为呢？就是要耗费的能量绝对是非常大罢了，看你觉不觉得值就是了。。。

## 语言/工具选择
- Go
  - 加分项
    - 上手简单：这真没得说的，很多库随手可得。
    - 弱化水平差距：不管你是新手还是大牛，不管你初学还是写了几年，上手以后你会发现居然都差不多。
    - 跨平台：这个没得说
    - 协程，多线程：这块确实做的不错
  - 减分项
    - 语法丑陋：不用我说了吧，居然还没有泛型
    - 狂热到近乎不可理喻的社区环境
- Rust
  - 加分项
    - 忠实于Functional Programming。
    - 追求零开销
    - 跨平台
    - 包管理：用过就知道，这点确实是没问题的
  - 减分项
    - 过于激进：上一个版本正常的特性下一个版本能给你要么搞炸了要么不兼容。
    - 门槛高：实际上要求你必须会C和C++，哪怕嘴上没说。
- C#
  - 加分项
    - 通吃：前后端都能打
    - 符合人类思维：能将你思考的结果忠实的反映在代码上
    - 跨平台：.NET Core以后追求跨平台，可圈可点
    - 设计优秀：这个是真没什么好说的
  - 减分项
    - 巨硬：请参考UWP事件，以及微软有的时候强推一些东西就是在犯病
    - 全家桶：你懂的。

为什么这里只列出上述这三门语言：这三门语言都有作为"工具语言"的能力，且对系统资源的占用相对来说比较小，又能实现后文所描述的诸多有关网络相关的功能。
> 更重要的是上述三个语言都能编译成静态二进制文件。


其他语言（如C/C++, Java, Python）要么实在是过于小题大做，要么占用过大，要么没办法静态编译。


## 设计思路
前面提到，我们需要拆分，本文的拆分方案相对来说比较简单：{CLI，中继器，服务器}

- CLI：执行指令。
- 中继器：接收CLI发送过来的指令（如有），并根据情况转发至服务器以执行下一步的内容。
- 服务器：对应游戏服务器的包装，相当于一个多功能的Daemon。

在设计交互之前，我们需要明确需要有哪些指令，根据这些指令来决定对应的实现相对来说会更简单。
- `gsm`：总指令，不做任何内容，只是用于输出帮助。
- `gsm update`：升级GSM，只升级bin的内容。
  - 不需要使用网络请求。
  - 在你更新前会有不少于一次的警告让你再三考虑确认。
  - 参考中继器和服务器关闭说明
  - 参数列表
    - `--content`：选择更新内容
      - 属性
        - 类型: `String`
        - 默认值: `all`
        - 标签
          - 选择
            - 只能选择如下内容
              - `cli`: 控制台
              - `coordinator`: 中继器
              - `server`: 服务器
          - 可选
            - 如果不显式声明该参数，或值为`all`，则为默认选项，默认全部更新。
- `gsm coordinator`：中继器总指令，不做任何内容，只用于输出帮助。
- `gsm coordinator start`：启动中继器。
  - 此项不需要使用网络请求。
- `gsm coordinator stop`：关闭中继器。
  - 此项应该使用网络请求 (大概率HTTP)
  - 除非显式要求(见参数列表)，否则中继器离线不影响连接了这个中继器的其他中继器/服务器。它们会一直尝试重新连接，直到达到某个预设条件(已连接/达到最大次数/用户要求关闭等)
  - 参数列表
    - `--recursive`：关闭所连接的中继器/服务器。
      - 属性
        - 类型：`String`
        - 默认值：`none`
        - 标签
          - 选择
            - 只能选择如下内容
              - `all`: 全部关闭
              - `server`: 只关闭服务器
              - `coordinator`: 只关闭中继器
              - `none`: 什么都不关
          - 可选
            - 如果不显式声明该参数，或值为`none`，则为默认选项，不关闭任何内容。
- `gsm coordinator restart`：重启中继器。
  - 只是关了再开，不关闭任何东西。
- `gsm coordinator status`：查看这台中继器的状态，比如有多少中继器连接，有多少服务器连接，诸如此类
  - 应该使用网络请求（如HTTP）
  - 参数列表
    - `--recursive`：请求所连接的所有中继器/服务器
      - 属性
        - 类型：`Boolean`
        - 默认值: `false`
        - 注意：如果所连接的内容非常多，小心把资源搞炸了。
        - 标签
          - 可选
            - 默认为`False`，不会递归请求。
- `gsm server start`：启动服务器。
  - 不需要网络请求
- `gsm server stop`：关闭服务器。
  - 使用网络请求(如HTTP)以实现正常退出。
- `gsm server restart`：重新启动服务器
  - 只是先关闭再启动。
- `gsm server update`：更新服务器
  - 不是所有服务器都能享受到这个服务（比如说这个服务器显式要求拒绝更新，抑或是没办法提供更新服务的）
  - 执行该命令必须确保为关闭状态（如果是在线状态使用的话将拒绝执行）
  - 不需要执行网络请求。
- `gsm server remove`：删除该服务器
  - 删除服务器文件，配置文件等所有与该ID有关的东西。
  - 删除以后这些已经使用过的ID将会保留，等新服务器安装的时候会优先使用他们（类似于回收机制）
  - 不需要使用网络请求。
- `gsm server console`：调用该服务器的控制台
  - 最难的机制，没有之一：重定向stdio到CLI，而且能交互。
  - 必须使用网络请求（这里十有八九websocket）。
  - 控制台输出的东西会保存为日志文件，供后期查阅。
- `gsm server backup`：备份该服务器
  - 备份该服务器的文件，还有配置。 
  - 不需要使用网络请求。
- `gsm server search`：搜索一个服务器
  - 视情况使用网络请求。
  - 仅为本机上比较初级的搜索，高级搜索请自行定制（如ElasticSearch云云）
  - 输入
    - `$Game`: 输入游戏名
      - 类型: `String`
      - 默认: `""`
      - 标签:
        - 依赖
          - 在输入标签的情况下可以不输入任何内容，但此时将会输出所有查询结果。否则，你必须输入内容，否则报错。
        - 必选 - 无标签
          - 无标签时必须输入内容
        - 可选 - 有标签
          - 有标签的情况下可以不输入任何内容，但会输出所有查询到的结果。
  - 参数列表
    - `--available`：可以安装的服务器
      - 属性
        - 类型：`Boolean`
        - 默认：`False`
        - 标签：
          - 可选
            - 如果开启这个标签，将会查找这个游戏是否可供安装。
    - `--installed`：已安装的服务器
      - 属性
        - 类型：`Boolean`
        - 默认：`False`
        - 标签：
          - 可选
            - 如果开启这个标签，将会查找这个游戏在本机的安装情况。
    - `--running`：正在运行的服务器
      - 属性
        - 类型：`Boolean`
        - 默认：`False`
        - 标签：
          - 可选
            - 如果开启这个标签，将会查找这个游戏在本机的运行情况。
            - 如果使用这个标签，将会发送一个请求至协调服务器，协调服务器将会根据请求的游戏查询正在运行的游戏数量。
- `gsm server install`：安装服务器
  - 不需要使用网络请求。
  - 安装服务器的同时需要检查依赖，比如说minecraft需要java，steamcmd要求i386以及那一大堆库，环境依赖等。
  - 同时生成配置。
  - 参数列表
    - `--game`：安装的是哪个游戏
      - 属性
        - 类型：`String`
        - 默认：`none`
        - 标签
          - 必选
            - 必须选择一个游戏，否则拒绝执行接下来的步骤
            - 必须选择列表中支持的游戏
    - `--related-to`：该服务器和哪个已安装的服务器有关。
      - 属性
        - 类型：`Int`
        - 默认：`-1`
        - 标签
          - 可选
            - 如果不显式声明该参数，或参数声明为`-1`，则表明为全新安装。
          - 依赖
            - 必须与GSM中安装了的服务器有关联。且如果与之关联的服务器被卸载，则该服务器也会被跟着一起卸载。
              > 本质上是创建软连接，所以才有如是般要求。
          - 互斥
            - 使用该参数时，不能同时存在`--import-from-exist`相关的参数，否则拒绝执行。
    - `--import-from-dir`
      - 依赖
        - 只有在声明`--import-from-exist`时才会启用该参数，否则即使你声明了该选项也不会有任何作用。
      - 可选
        - 由于其依赖性，故当该服务器并非从外部导入而为全新安装时，该选项则不需要做任何声明。
    - `--import-from-exist`：该需要安装的服务器是否通过一个已有的外部服务器包导入
      - 属性
        - 类型: `Boolean`
        - 默认: `False`
        - 标签
          - 可选
            - 默认为关闭，你可以显式声明它
          - 互斥
            - 一旦声明该选项，则无法使用`--related-to`，否则报错。
          - 依赖
            - 一旦声明该选项，则必须显式声明`--import-from-dir`，否则报错。

根据上述草案指令，我想设计思路应该非常明确了：

CLI<=>中继器：HTTP，WebSocket
- WebSocket仅在需要连接控制台时启用，其他时候可以关闭以节省资源
- 其他使用的交互基本只需要HTTP

中继器<=>终端：WebSocket
- 终端包括服务器和其他中继器
- 使用WebSocket是为了实现"在线"状态

## 细枝末节
- 服务器的配置，ID？
  - 本地配置。这个就没办法了，因为远程配置实际上麻烦的一批
    > 虽然的确是可以这么做但换汤不换药罢了，而且服务器的配置跟本地反而没那么多破事————你哪怕把这些搬到所谓的云服务上面去不还是干着一模一样的活？更何况你只是搞基础配置，复杂的配置你上云还差不多。再说了，你见过nginx的基础配置还要上云的？不都是auto-generate然后自己搞个config云服务器再细调。
- 中继器的配置？
  - 你确确实实可以搞一个配置服务器来专门配置这个东西。
  - 目前的方案是在GSM本地配置指定。
  - 你可以修改成连接配置服务器读取配置，这个我觉得应该很容易理解我的意思。
  - 是的，如果想查询所有节点的状态会非常吃资源。这里有很多种优化方法，比如说多个小集群然后统一发送到前端，又比如说全部集中在一个大型根节点然后统一处理云云。这个看你的实际情况决定。
- 开源版，商业版
  - 开源版和商业版之间在绝大多数上都相同，除了某些组件
    - 中继器
      - 开源版中，中继器之间的互相连接依赖IP地址，而商业版的连接则依赖数据库，并且还将额外增加一个组件，用于记录所有连接的服务器，相当于"影子"，用于记录拓扑结构。
      - 开源版中，服务器必须依赖本地中继器，而商业版可以连接远程中继器，随之而来的，配置也需要跟随数据库，以及这个额外的组件。

