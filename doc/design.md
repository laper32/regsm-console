# ReGSM

ReGSM = **Re**constructed **G**ame **S**erver **M**anager.

新世代的游戏服务器管理器

## 前言
服务器开发绝对不是一个什么特别舒服的事情，光在管理工具的选择上就足以让人头疼。

虽然说现在不同的平台已经有了各自的解决方案：
- Windows现在有一个可以说是大一统的 [**WindowsGSM**](https://github.com/WindowsGSM/WindowsGSM)
- Linux标配[**LinuxGSM**](https://github.com/GameServerManagers/LinuxGSM)

问题在于：
1. 平台限定：平台都写脸上了，所以这个工具也就只能针对特定平台，没法大一统
2. 重复劳动：不同平台的工具不同，所以我们需要重复劳动来解决相同的问题。
3. 各自的设计缺陷：下文会说

提出了问题就要解决问题，解决问题首先要明确我们要解决什么问题：
1. 大一统
2. 减少重复劳动
3. 屏蔽环境依赖
4. 易扩展
5. 简单易用

不过嘛，事情肯定不会有那么简单的。

不必多说，想要跨平台大一统，肯定不是什么容易的事情。。。尤其像是比如说tmux在linux下限定而windows用不了一样
> 不要说什么cygwin msys 我们只讨论原装

所幸，我们可以通过重定向stdio的方式来"Detour", aka, 不通过在服务器内部做对应的扩展（比如说V社的SM/MM/AMX，MC的BitBukket啥的），
转而通过重定向控制台应用的输入输出流，并通过其他的方法实现"后台运行"。
> 毕竟Non-GUI可不提供像是alt+tab这种功能，别做梦了。

但这样的话其实也不是什么很容易的事情，容我细细道来：
1. 需要自己造轮子：
   1. 避免平台依赖：LinuxGSM完完全全依赖tmux，WindowsGSM完完全全依赖Windows GUI。
      > 上文说到，WindowsGSM如果挂了下面的服务器实际上也是要跟着挂的
   2. 避免引入非必要依赖：如果想让windows支持tmux之类的软件需要安装msys或cygwin，但那样等同于没装，而且实际上也没办法做到和cmd/powershell互通，得不偿失。
   3. 跨平台兼容：参考 1.1)，不再说明。
2. 复杂度
   1. 拆分：我们提到没办法用tmux，所以你需要自己实现tmux的核心思想。这时候相当于说你需要看情况拆分一些内容，以期实现平台无关。
      > 有些Lin有的Win没有，反过来也一样，所以就得绕一大圈，确保跨平台兼容。
   2. 完全基于网络：因为需要拆分，所以在端对端的交互上是无可避免的要使用诸如HTTP, Socket, WebSocket等技术，这对于复杂度来说实际上是指数型上升的。
      > 虽然说有些号称"大道至简"的语言信誓旦旦的说复杂度会非常低，但是吧，我很怀疑：一个项目复杂度只要上升到足够高，任何所谓的简单其实都只是噱头。
   3. 技术储备：你需要手动实现如daemon, HTTP/Websocket等传递信息到stdin，输出stdout到其他终端/前端，前后端交互，节点等。这些内容哪个都不是什么小问题。

## 产品分析
### WindowsGSM
优：
- 大一统了Windows平台下的管理方案：以前都是各搞各的，要么自己手搓命令行，要么自己写工具。至少大大降低了很多人的入门难度。
- 简单上手易用：真的很简单了，手指按按解决一切问题

劣:
- 写的不太行：如果你翻源代码你会发现许多匪夷所思的写法。
- 耦合度高：如果这个管理系统挂掉了，那么代表着下面的所有服务器全部都要跟着挂————如果那些服务器有人的话就完蛋
- 莫名其妙的bug多：比如说自动更新经常失效云云

### LinuxGSM
优：
- 唯一解：得益于Linux环境下大家都是命令行，所以干事都很方便(Bash解决一切问题)
- 一键操作：也是一样的，根据教程敲敲命令行解决一切问题

劣：
- 依赖tmux：实际上这套管理系统是完完全全依赖tmux的，没tmux就完蛋
- 乱：因为是用bash写的，然而bash写的东西往往写着写着就不是人类能读懂的————虽然说确实是好东西就是了

### 其他
上述的分析实际上也只是从一个使用者的角度来分析。但从易用性角度来看，我们应该先将所有的底层操作封装好，然后再在上层提供对应的界面（如桌面版客户端，Web前端等）

然而上述二者虽好用，但却不见得能解决我们的需求：
- 屏蔽环境依赖：屏蔽一切形如操作系统（换言之，Lin/Win都可），依赖库，Java版本等影响
- 简单易用：如果你是偏专业人员就使用命令行，如果你懒得搞/第一次使用就用图形界面
- 易扩展：你可以随意水平垂直扩展
- 减少重复劳动：一次劳动解决所有问题
- 大一统：Lin也好，Win也罢，安装完直接用，不用管他那么多

针对我们的需求，我们需要在下文中简要介绍一下Dota2的网络架构

### Dota2
倘若你玩过Dota2，想必你一定是知道红蓝字是什么的
> 正在搜索 Dota 2 游戏协调服务器

你肯定看到过这个，所以我们就根据这个来做点简单的研究。

启动Dota2的过程：
1. 启动Dota 2
2. 加载所需的一切库(kernel32.dll, tier0.dll, ...)
3. 加载缓存资源（美术，音效等）
4. **连接Steam网络**
   1. 连接Steam网络(steam_api.dll)
      > 这一步判断你是否是离线模式
   2. 连接后，获取协调服务器IP地址，并寻找延迟最低的连接 
      > Searching to the dota 2 coordinator 
   3. 找到了这个地址后，连接，并发送形如你的Steam ID等信息
      > Connected to the Dota 2 coordinator, logging in
   4. 信息收到，建立连接，已登入
      > 这时候你上面的红蓝字就消失
5. Do further action

所以，发现没，这个流程，我们完全可以拿来用，就可以利用这套机制解耦，水平垂直都可以无限扩展

针对这个流程，我们将分成以下几个部分：
1. CLI: 命令行，用来操作本机环境的
2. Coordinator: 字如其名
3. Daemon: 用来和特定的服务器交互，接收红蓝字传来的数据
4. Client: 客户端，图形操作界面

很明显，这四个部分，我们是不能，也不可能锁死一个语言完成的：根本不可能完成的任务。

我们需要使用多个语言完成。

## 语言/工具选择
- Go
  - 加分项
    - 上手简单：这真没得说的，很多库随手可得。
    - 弱化水平差距：不管你是新手还是大牛，不管你初学还是写了几年，上手以后你会发现居然都差不多。
    - 跨平台：这个没得说
    - 协程，多线程：这块确实做的不错
  - 减分项
    - 语法丑陋：不用我说了吧，居然还没有泛型
    - 狂热到近乎不可理喻的社区环境
    - 无法深入操作系统底层：一写便知，不必多言
- C#
  - 加分项
    - 通吃：前后端都能打
    - 符合人类思维：能将你思考的结果忠实的反映在代码上
    - 跨平台：.NET Core以后追求跨平台，可圈可点
    - 设计优秀：这个是真没什么好说的
  - 减分项
    - 巨硬：请参考UWP事件，以及微软有的时候强推一些东西就是在犯病
    - 全家桶：你懂的。

为什么这里只列出上述语言：这些语言都有作为"工具语言"的能力，且对系统资源的占用相对来说比较小，又能实现后文所描述的诸多有关网络相关的功能。
> 更重要的是上述三个语言都能编译成静态二进制文件。

其他语言（如C/C++, Java, Python）要么实在是过于小题大做，要么占用过大，要么没办法静态编译。

## 行为要求
### 命令行
到目前为止，命令行都有若干确定的指令，也有若干确定的行为。将在下文详细说明

行为要求
1. 正确写入，更新配置文件
2. 指令预期行为正确

#### 服务器
|指令|行为|
|:-:|:-:|
|attach|与服务器命令行交互|
|backup|备份服务器|
|install|安装服务器，提供符号连接，从外部安装包导入的选项
|remove|删除服务器|
|restart|重启服务器|
|search|搜索。可搜索服务器，也可搜索提供安装的游戏服务器|
|send|发送指令到对应服务器，并执行对应的行为|
|start|开启服务器，启动Daemon，剩下的交由Daemon解决|
|stop|关闭服务器|
|update|更新服务器|
|validate|验证服务器完整性|

#### 红蓝字
|指令|行为|
|:-:|:-:|
|restart|重启红蓝字|
|start|启动红蓝字|
|stop|关闭红蓝字|

### Daemon
行为要求
1. 启动后需要立刻连接红蓝字，连接不上应该直接挂掉
2. 连接成功后需要立刻启动服务器，且启动方式需要根据操作系统，游戏等做正确配置，且能正确启动
3. 具备断线重连功能，崩溃重启等功能

### 红蓝字
行为要求
1. 正确处理Daemon的连接
2. 正确处理命令行指令转发
3. 正确处理Attach交互功能
### 客户端
行为要求
1. 提供一个易用的客户端界面（ambiguous）
2. 正确反应框架的拓扑结构
